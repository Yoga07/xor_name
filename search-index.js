var searchIndex = JSON.parse('{\
"xor_name":{"doc":"xor_nameTODO requires further documentation.","i":[[3,"Prefix","xor_name","A section prefix, i.e. a sequence of bits specifying the …",null,null],[17,"XOR_NAME_LEN","","Constant byte length of <code>XorName</code>.",null,null],[3,"XorName","","A 256-bit number, viewed as a point in XOR space.",null,null],[12,"0","","",0,null],[11,"from_content","","Generate a XorName for the given content (for …",0,[[]]],[11,"random","","Generate a random XorName",0,[[]]],[11,"bit","","Returns <code>true</code> if the <code>i</code>-th bit is <code>1</code>.",0,[[["u8",15]],["bool",15]]],[11,"cmp_distance","","Compares the distance of the arguments to <code>self</code>. Returns …",0,[[],["ordering",4]]],[14,"xor_name","","Creates XorName with the given leading bytes and the rest …",null,null],[11,"from","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"vzip","","",1,[[]]],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"vzip","","",0,[[]]],[11,"deref","","",0,[[]]],[11,"fmt","","",1,[[["formatter",3]],["fmtresult",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"eq","","",1,[[],["bool",15]]],[11,"eq","","",0,[[["xorname",3]],["bool",15]]],[11,"ne","","",0,[[["xorname",3]],["bool",15]]],[11,"cmp","","",1,[[],["ordering",4]]],[11,"cmp","","",0,[[["xorname",3]],["ordering",4]]],[11,"partial_cmp","","",1,[[],[["ordering",4],["option",4]]]],[11,"partial_cmp","","",0,[[["xorname",3]],[["ordering",4],["option",4]]]],[11,"lt","","",0,[[["xorname",3]],["bool",15]]],[11,"le","","",0,[[["xorname",3]],["bool",15]]],[11,"gt","","",0,[[["xorname",3]],["bool",15]]],[11,"ge","","",0,[[["xorname",3]],["bool",15]]],[11,"not","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"hash","","",0,[[]]],[11,"from_str","","",1,[[["str",15]],["result",4]]],[11,"as_ref","","",0,[[]]],[11,"as_ref","","",0,[[]]],[11,"fmt","","",1,[[["formatter",3]],["fmtresult",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"clone","","",1,[[],["prefix",3]]],[11,"clone","","",0,[[],["xorname",3]]],[11,"default","","",1,[[],["prefix",3]]],[11,"default","","",0,[[],["xorname",3]]],[11,"serialize","","",1,[[],["result",4]]],[11,"serialize","","",0,[[],["result",4]]],[11,"deserialize","","",1,[[],["result",4]]],[11,"deserialize","","",0,[[],["result",4]]],[11,"new","","Creates a new <code>Prefix</code> with the first <code>bit_count</code> bits of <code>name</code>…",1,[[["usize",15],["xorname",3]]]],[11,"name","","Returns the name of this prefix.",1,[[],["xorname",3]]],[11,"pushed","","Returns <code>self</code> with an appended bit: <code>0</code> if <code>bit</code> is <code>false</code>, and …",1,[[["bool",15]]]],[11,"popped","","Returns a prefix copying the first <code>bitcount() - 1</code> bits …",1,[[]]],[11,"bit_count","","Returns the number of bits in the prefix.",1,[[],["usize",15]]],[11,"is_empty","","Returns <code>true</code> if this is the empty prefix, with no bits.",1,[[],["bool",15]]],[11,"is_compatible","","Returns <code>true</code> if <code>self</code> is a prefix of <code>other</code> or vice versa.",1,[[],["bool",15]]],[11,"is_extension_of","","Returns <code>true</code> if <code>other</code> is compatible but strictly shorter …",1,[[],["bool",15]]],[11,"is_neighbour","","Returns <code>true</code> if the <code>other</code> prefix differs in exactly one …",1,[[],["bool",15]]],[11,"common_prefix","","Returns the number of common leading bits with the input …",1,[[["xorname",3]],["usize",15]]],[11,"matches","","Returns <code>true</code> if this is a prefix of the given <code>name</code>.",1,[[["xorname",3]],["bool",15]]],[11,"cmp_distance","","Compares the distance of <code>self</code> and <code>other</code> to <code>target</code>. …",1,[[["xorname",3]],["ordering",4]]],[11,"cmp_breadth_first","","Compares the prefixes using breadth-first order. That is, …",1,[[],["ordering",4]]],[11,"lower_bound","","Returns the smallest name matching the prefix",1,[[],["xorname",3]]],[11,"upper_bound","","Returns the largest name matching the prefix",1,[[],["xorname",3]]],[11,"range_inclusive","","Inclusive range from lower_bound to upper_bound",1,[[],[["rangeinclusive",3],["xorname",3]]]],[11,"is_covered_by","","Returns whether the namespace defined by <code>self</code> is covered …",1,[[],["bool",15]]],[11,"with_flipped_bit","","Returns the neighbouring prefix differing in the <code>i</code>-th bit …",1,[[["u8",15]]]],[11,"substituted_in","","Returns the given <code>name</code> with first bits replaced by <code>self</code>",1,[[["xorname",3]],["xorname",3]]],[11,"sibling","","Returns the same prefix, with the last bit flipped, or …",1,[[]]],[11,"ancestor","","Returns the ancestors of this prefix that has the given …",1,[[["u8",15]]]],[11,"ancestors","","Returns an iterator that yields all ancestors of this …",1,[[],["ancestors",3]]]],"p":[[3,"XorName"],[3,"Prefix"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);